# 继承的实现方式

## 只继承会共享的原型方法

```js
function SuperType() {
  this.name = 'Yvette';
}
function SubType() {
  this.age = 22;
}
SubType.prototype = SuperType;
```

## 继承会共享的实例方法和会共享的原型方法

以下方式通过原型链实现，会导致所有子类都会共享实例方法的状态。

```js
function SuperType() {
  this.name = 'Yvette';
}
function SubType() {
  this.age = 22;
}
SubType.prototype = new SuperType();
```

## 只继承不共享的实例方法

以下方式通过构造函数实现，子类可以拥有各自的实例方法。

```javascript
function SuperType(name) {
  this.name = name;
}

function SubType(name) {
  SuperType.call(this, name);
}
```

## 继承不会共享的实例方法和会共享的原型方法

```js
function SuperType() {
  this.name = 'zc';
  this.colors = ['pink', 'blue', 'green'];
}
function SubType() {
  SuperType.call(this);
}
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
let a = new SubType();
let b = new SubType();

a.colors.push('red');
console.log(a.colors); //[ 'pink', 'blue', 'green', 'red' ]
console.log(b.colors); //[ 'pink', 'blue', 'green' ]
```

## 参考

[面试专题总结：原型和原型链](https://juejin.cn/post/6844904096827195399)
